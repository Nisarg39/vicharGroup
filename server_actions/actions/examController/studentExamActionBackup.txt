export async function submitExamResult(examData) {
  /**
   * OPTIMIZED SUBMISSION ROUTING - submitExamResult(examData)
   * 
   * NEW ARCHITECTURE:
   * 1. Check for pre-computed client evaluation results (Priority 1)
   * 2. Route to ultra-fast optimized endpoint (15-50ms target)
   * 3. Fallback to emergency queue system (Background processing)
   * 4. Final fallback to traditional computation (Synchronous)
   * 
   * PERFORMANCE TARGETS:
   * - Client evaluation + optimized endpoint: 15-50ms total
   * - Queue system: Immediate response + background processing
   * - Traditional computation: 400-1,350ms (fallback only)
   */
  
  const routingStartTime = Date.now();
  
  // PRIORITY 1: Check for pre-computed client evaluation results
  if (examData.clientEvaluationResult || examData.progressiveResults || examData.isPreComputed) {
    try {
      console.log('⚡ ROUTING: Pre-computed results detected, using optimized submission...');
      
      const { routeOptimizedSubmission } = await import('./optimizedSubmissionEndpoint');
      
      const optimizedResult = await routeOptimizedSubmission(examData);
      
      const totalRoutingTime = Date.now() - routingStartTime;
      
      return {
        ...optimizedResult,
        routingDecision: 'optimized_endpoint',
        routingTime: totalRoutingTime,
        performanceAchieved: optimizedResult.performanceMetrics?.totalTime <= 50
      };
      
    } catch (optimizedError) {
      console.warn('⚠️ Optimized submission failed, falling back to queue system:', optimizedError.message);
      // Continue to queue system fallback
    }
  }
  
  // PRIORITY 2: Emergency queue system for background processing
  const useQueueSystem = process.env.EXAM_QUEUE_ENABLED !== 'false' && 
                          process.env.NODE_ENV === 'production';
  
  if (useQueueSystem) {
    try {
      console.log('📋 ROUTING: Using emergency queue system for background processing...');
      
      const { queueExamSubmission } = await import('../../utils/examSubmissionQueue.js');
      
      // Get request context for better queue management
      const context = {
        isAutoSubmit: examData.isAutoSubmit || false,
        isManualSubmit: !examData.isAutoSubmit,
        timeRemaining: examData.timeRemaining || 0,
        examEnded: examData.examEnded || false,
        userAgent: examData.userAgent,
        screenResolution: examData.screenResolution,
        timezone: examData.timezone,
        sessionId: examData.sessionId,
        ipAddress: examData.ipAddress,
        hasClientEvaluation: !!(examData.clientEvaluationResult || examData.progressiveResults)
      };
      
      const queueResult = await queueExamSubmission(examData, context);
      
      if (queueResult.success) {
        const totalRoutingTime = Date.now() - routingStartTime;
        
        return {
          success: true,
          message: "Your exam has been submitted successfully! Your results are being processed and will be available shortly.",
          isQueued: true,
          submissionId: queueResult.submissionId,
          estimatedProcessingTime: queueResult.estimatedProcessingTime,
          routingDecision: 'queue_system',
          routingTime: totalRoutingTime,
          result: {
            isProcessing: true,
            submissionId: queueResult.submissionId,
            message: "Processing your answers in the background...",
            completedAt: new Date(),
            timeTaken: examData.timeTaken,
            warnings: examData.warnings || 0
          }
        };
      } else {
        console.warn('Queue system failed, falling back to traditional processing:', queueResult.message);
      }
      
    } catch (queueError) {
      console.error('Queue system error, falling back to traditional processing:', queueError.message);
    }
  }
  
  // PRIORITY 3: Traditional synchronous processing (final fallback)
  console.log('🔄 ROUTING: Using traditional synchronous processing as final fallback...');
  
  const traditionalResult = await retryExamSubmission(submitExamResultInternal, examData);
  const totalRoutingTime = Date.now() - routingStartTime;
  
  return {
    ...traditionalResult,
    routingDecision: 'traditional_computation',
    routingTime: totalRoutingTime,
    isFallback: true
  };
}