'use client'

import React, { useRef, useState, useEffect, useCallback, useMemo } from 'react';
import dynamic from 'next/dynamic';
import 'suneditor/dist/css/suneditor.min.css';
import 'katex/dist/katex.min.css';
import axios from 'axios';

// import plugins helper to add custom plugins
import plugins from 'suneditor/src/plugins';

import { getTopics } from '../../../../../utils/examUtils/subject_Details';
import { addExamQuestion, updateExamQuestion, getPredefinedMarks } from '../../../../../server_actions/actions/adminActions';

// Dynamic import for SunEditor (SSR-safe)
const SunEditor = dynamic(() => import('suneditor-react'), {
  ssr: false,
  loading: () => <div className="h-[200px] flex items-center justify-center bg-gray-50">Loading editor...</div>
});

// Simple KaTeX getter
const getKaTeX = async () => {
  try {
    // Try to get KaTeX from window first
    if (window.katex && typeof window.katex.render === 'function') {
      return window.katex;
    }
    
    // If not available, try dynamic import
    const katexModule = await import('katex');
    const katex = katexModule.default || katexModule;
    window.katex = katex;
    return katex;
  } catch (err) {
    console.warn('KaTeX not available:', err);
    return null;
  }
};


// ---------- Helper: list of special characters (same as your Quill toolbar list) ----------
const SPECIAL_CHARS = [
  '±','∓','×','÷','∑','∏','√','∛','∜','∫','∮','∯','∰','∂','∇','∆','∞','∝','≈','≠',
  '≡','≤','≥','⊂','⊃','⊆','⊇','∈','∉','∋','∌','∩','∪','⊥','α','β','γ','δ','ε','ζ','η',
  'θ','ι','κ','λ','μ','ν','ξ','π','ρ','σ','τ','υ','φ','χ','ψ','ω','Δ','Π','Σ','Φ','Ψ',
  'Ω','°','′','″','℃','℉','⇒','⇔','←','→','↑','↓','↔','↕'
];

// ---------- Enhanced Formula Plugin with better detection ----------
plugins.formula = {
  name: 'formula',
  display: 'command', 
  title: 'Insert formula (KaTeX)',
  buttonClass: '',
  innerHTML: '<b>∑</b>',
  add: function (core, targetElement) {
    const context = core.context;
    context.formula = {};
  },
  active: function (element) {
    return false;
  },
  action: async function (core, targetElement) {
    const latex = window.prompt('Enter LaTeX expression (without $):', '');
    if (!latex) return;
    
    try {
      // Load KaTeX first
      let katex;
      try {
        if (window.katex && typeof window.katex.render === 'function') {
          katex = window.katex;
        } else {
          const katexModule = await import('katex');
          katex = katexModule.default || katexModule;
          window.katex = katex;
        }
      } catch (err) {
        console.warn('KaTeX not available:', err);
        katex = null;
      }

      if (katex && typeof katex.renderToString === 'function') {
        try {
          // For editor display, use a simplified approach to avoid SVG issues
          // Just show the LaTeX with nice styling - actual rendering happens in preview
          const editorDisplay = `<span style="
            background: #f0f8ff;
            border: 1px solid #4a90e2;
            border-radius: 4px;
            padding: 2px 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #2c5aa0;
            display: inline-block;
            margin: 0 2px;
          ">${latex}</span>`;
          
          // Insert as ql-formula with the LaTeX display for editor, but keep data-value for preview rendering
          const html = `<span class="ql-formula" data-value="${latex.replace(/"/g, '&quot;')}" contenteditable="false">${editorDisplay}</span>`;
          core.insertHTML(html);
        } catch (renderErr) {
          console.warn('KaTeX render error:', renderErr);
          // Fallback to plain text
          const html = `<span class="ql-formula" data-value="${latex.replace(/"/g, '&quot;')}" style="font-style: italic; color: #e74c3c;">[Math: ${latex}]</span>`;
          core.insertHTML(html);
        }
      } else {
        // Fallback when KaTeX is not available
        const html = `<span class="ql-formula" data-value="${latex.replace(/"/g, '&quot;')}" style="font-style: italic; color: #666;">[Math: ${latex}]</span>`;
        core.insertHTML(html);
      }
    } catch (err) {
      console.error('Formula plugin error:', err);
      // Final fallback
      const html = `<span class="ql-formula" data-value="${latex.replace(/"/g, '&quot;')}" style="font-style: italic; color: #e74c3c;">[Math: ${latex}]</span>`;
      core.insertHTML(html);
    }
  }
};

// Enhanced Special-chars plugin with better UI
plugins.specialChars = {
  name: 'specialChars',
  display: 'command',
  title: 'Insert special character',
  buttonClass: '',
  innerHTML: 'Ω',
  command: function (core) {
    // Create a better dialog for character selection
    const modalHtml = `
      <div id="special-chars-modal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;">
        <div style="background: white; padding: 20px; border-radius: 8px; max-width: 600px; max-height: 80vh; overflow-y: auto;">
          <h3 style="margin: 0 0 15px 0; font-size: 18px;">Select Special Character</h3>
          <div style="display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; margin-bottom: 15px;">
            ${SPECIAL_CHARS.map((char, i) => 
              `<button onclick="insertSpecialChar('${char}')" style="padding: 8px; border: 1px solid #ccc; background: #f9f9f9; cursor: pointer; font-size: 16px; border-radius: 4px;" title="${char}">${char}</button>`
            ).join('')}
          </div>
          <div style="text-align: right;">
            <button onclick="closeSpecialCharsModal()" style="padding: 8px 16px; border: 1px solid #ccc; background: #f5f5f5; cursor: pointer; border-radius: 4px;">Cancel</button>
          </div>
        </div>
      </div>
    `;
    
    // Add modal to body
    const modalElement = document.createElement('div');
    modalElement.innerHTML = modalHtml;
    document.body.appendChild(modalElement.firstElementChild);
    
    // Global functions for the modal
    window.insertSpecialChar = (char) => {
      core.insertText(char);
      closeSpecialCharsModal();
    };
    
    window.closeSpecialCharsModal = () => {
      const modal = document.getElementById('special-chars-modal');
      if (modal) {
        modal.remove();
      }
      delete window.insertSpecialChar;
      delete window.closeSpecialCharsModal;
    };
  }
};

// ---------- Component ----------
const AddQuestion = ({ subjects, questionToEdit, onClose, onUpdate }) => {
  // editor ref (single editor instance reused across tabs)
  const editorRef = useRef(null);

  const [tabValue, setTabValue] = useState(0);
  const [adminToken, setAdminToken] = useState(null);
  const [isEditorReady, setIsEditorReady] = useState(false);
  const [editorError, setEditorError] = useState(null);
  const [topics, setTopics] = useState([]);
  const [markingInfo, setMarkingInfo] = useState(null);

  const [isUploading, setIsUploading] = useState(false);


  const [formData, setFormData] = useState({
    stream: questionToEdit?.stream || 'NEET',
    subject: questionToEdit?.subject || (subjects && subjects.length > 0 ? subjects[0].value : ''),
    standard: questionToEdit?.standard || '',
    section: questionToEdit?.section || '',
    topic: questionToEdit?.topic || '',
    question: questionToEdit?.question || '',
    optionA: questionToEdit?.options?.[0] || '',
    optionB: questionToEdit?.options?.[1] || '',
    optionC: questionToEdit?.options?.[2] || '',
    optionD: questionToEdit?.options?.[3] || '',
    answer: questionToEdit?.answer || '',
    marks: questionToEdit?.marks || '',
    userInputAnswer: questionToEdit?.userInputAnswer || false,
    isMultipleAnswer: questionToEdit?.isMultipleAnswer || false,
    multipleAnswer: questionToEdit?.multipleAnswer || [],
    difficultyLevel: questionToEdit?.difficultyLevel || 'Easy',
  });

  const [previewContent, setPreviewContent] = useState({
    question: '',
    optionA: '',
    optionB: '',
    optionC: '',
    optionD: ''
  });

  // ---------- Fetch admin token same as original ----------
  useEffect(() => {
    const getAdminToken = async () => {
      try {
        const response = await axios.post('https://api.drcexam.in/user/auth/signin', {
          email: 'admin.support@drcexam.in',
          password: 'Exam@2024',
          remember: true
        });
        const token = response.data.payload.token;
        setAdminToken(token);
      } catch (error) {
        console.log('Admin authentication error:', error);
      }
    };
    getAdminToken();
  }, []);

  // ---------- Initialize KaTeX and helper functions ----------
  useEffect(() => {
    (async () => {
      if (typeof window !== 'undefined' && !window.katex) {
        try {
          const katexPkg = await import('katex');
          window.katex = katexPkg.default || katexPkg;
        } catch (err) {
          console.warn('katex import failed', err);
        }
      }
      
      // Enhanced math expression detection and rendering functions
      window.renderAllMathExpressions = () => {
        document.querySelectorAll('.se-math, .katex-expression').forEach(el => {
          if (el.dataset.latex) {
            try {
              if (window.katex && typeof window.katex.render === 'function') {
                const latex = el.dataset.latex;
                el.innerHTML = '';
                window.katex.render(latex, el, { 
                  throwOnError: false,
                  displayMode: false,
                  output: 'html'
                });
                el.style.border = 'none';
                el.style.background = 'transparent';
                el.style.padding = '0';
              } else {
                el.textContent = `[Math: ${el.dataset.latex}]`;
              }
            } catch (err) {
              el.textContent = `[Math: ${el.dataset.latex}]`;
              el.style.color = '#e74c3c';
            }
          }
        });
      };
      
      // Function to detect common mathematical expressions and convert them
      window.detectAndConvertMathExpressions = () => {
        const editorInstance = editorRef.current?.editor;
        if (!editorInstance) return;
        
        try {
          let editorContent = editorInstance.getContents();
          if (!editorContent) return;
          
          // Skip processing if content already has ql-formula elements to avoid conflicts
          if (editorContent.includes('class="ql-formula"')) {
            return;
          }
          
          
          // Common mathematical patterns to detect and auto-convert
          const mathPatterns = [
            // Square roots: sqrt(x) -> √x or ∜x
            { regex: /\\sqrt\{([^}]+)\}/g, replacement: '√($1)' },
            { regex: /sqrt\(([^)]+)\)/g, replacement: '√($1)' },
            
            // Fractions: a/b -> fraction notation when appropriate (but not in URLs or paths)
            { regex: /(?<![\w\/])(\d+)\/(\d+)(?![\w\/])/g, replacement: (match, num, den) => `<span class="se-math" data-latex="\\\\frac{${num}}{${den}}"></span>` },
            
            // Powers: x^2 -> x²
            { regex: /\^([0-9]+)/g, replacement: (match, power) => {
              const superscripts = ['⁰','¹','²','³','⁴','⁵','⁶','⁷','⁸','⁹'];
              return power.split('').map(d => superscripts[parseInt(d)] || d).join('');
            }},
            
            // Common function notations
            { regex: /\\sum(?![a-z])/g, replacement: '∑' },
            { regex: /\\prod(?![a-z])/g, replacement: '∏' },
            { regex: /\\int(?![a-z])/g, replacement: '∫' },
            { regex: /\\partial(?![a-z])/g, replacement: '∂' },
            { regex: /\\nabla(?![a-z])/g, replacement: '∇' },
            { regex: /\\Delta(?![a-z])/g, replacement: 'Δ' },
            { regex: /\\infty(?![a-z])/g, replacement: '∞' },
            { regex: /\\pi(?![a-z])/g, replacement: 'π' },
            { regex: /\\alpha(?![a-z])/g, replacement: 'α' },
            { regex: /\\beta(?![a-z])/g, replacement: 'β' },
            { regex: /\\gamma(?![a-z])/g, replacement: 'γ' },
            { regex: /\\delta(?![a-z])/g, replacement: 'δ' },
            { regex: /\\theta(?![a-z])/g, replacement: 'θ' },
            { regex: /\\lambda(?![a-z])/g, replacement: 'λ' },
            { regex: /\\mu(?![a-z])/g, replacement: 'μ' },
            { regex: /\\sigma(?![a-z])/g, replacement: 'σ' },
            { regex: /\\phi(?![a-z])/g, replacement: 'φ' },
            { regex: /\\omega(?![a-z])/g, replacement: 'ω' },
            
            // Comparison operators
            { regex: /\<\=/g, replacement: '≤' },
            { regex: /\>\=/g, replacement: '≥' },
            { regex: /!\=/g, replacement: '≠' },
            { regex: /\~\=/g, replacement: '≈' },
            
            // Special expressions wrapped in $...$ or $$...$$ 
            { regex: /\$\$([^$]+)\$\$/g, replacement: (match, latex) => `<span class="se-math" data-latex="${latex.trim()}" style="display: block; text-align: center;"></span>` },
            { regex: /\$([^$]+)\$/g, replacement: (match, latex) => `<span class="se-math" data-latex="${latex.trim()}"></span>` }
          ];
          
          let modifiedContent = editorContent;
          let hasChanges = false;
          
          // Check if we converted any Quill formulas
          if (modifiedContent !== editorContent) {
            hasChanges = true;
          }
          
          mathPatterns.forEach(pattern => {
            const originalContent = modifiedContent;
            modifiedContent = modifiedContent.replace(pattern.regex, pattern.replacement);
            if (modifiedContent !== originalContent) {
              hasChanges = true;
            }
          });
          
          // Only update if we found mathematical expressions
          if (hasChanges) {
            editorInstance.setContents(modifiedContent);
            // Render the new math expressions
            setTimeout(() => window.renderAllMathExpressions(), 50);
          }
        } catch (err) {
          console.warn('Math expression detection error:', err);
        }
      };
    })();
  }, []);

  // ---------- processImages - convert data: URLs -> upload to S3 and replace ----------
  const processImages = useCallback(async (html) => {
    setIsUploading(true);
    if (typeof window === 'undefined') {
      setIsUploading(false);
      return html;
    }
    try {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html || '', 'text/html');
      const images = doc.querySelectorAll('img');
      for (const img of images) {
        const src = img.getAttribute('src');
        if (src && src.startsWith('data:')) {
          const mime = (src.match(/data:([^;]+);base64,/) || [])[1];
          const base64Data = src.split(',')[1];
          const byteCharacters = atob(base64Data);
          const byteNumbers = new Array(byteCharacters.length).fill(0).map((_, i) => byteCharacters.charCodeAt(i));
          const byteArray = new Uint8Array(byteNumbers);
          const file = new Blob([byteArray], { type: mime });
          const fileName = `image_${Date.now()}.png`;

          const response = await fetch('https://api.drcexam.in/getPreSignedURL', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${adminToken}`
            },
            body: JSON.stringify({ fileName, type: 'questionImage' })
          });
          const data = await response.json();
          const preSignedURL = data.payload;
          await fetch(preSignedURL, { method: 'PUT', body: file });
          const uploadedUrl = preSignedURL.split('?')[0];
          img.setAttribute('src', uploadedUrl);
        }
      }
      setIsUploading(false);
      return doc.body.innerHTML;
    } catch (err) {
      console.error('processImages error', err);
      setIsUploading(false);
      return html;
    }
  }, [adminToken]);

  // ---------- Image upload to S3 (used by toolbar/paste/drag drop) ----------
  const uploadFileToS3 = useCallback(async (file) => {
    if (!adminToken) throw new Error('No admin token for upload');
    const fileName = file.name || `image_${Date.now()}.png`;
    const payload = {
      fileName,
      type: 'questionImage'
    };
    const resp = await fetch('https://api.drcexam.in/getPreSignedURL', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${adminToken}` },
      body: JSON.stringify(payload)
    });
    const json = await resp.json();
    const preSignedURL = json.payload;
    await fetch(preSignedURL, { method: 'PUT', body: file });
    return preSignedURL.split('?')[0];
  }, [adminToken]);

  // ---------- SunEditor: onImageUploadBefore (toolbar handler) ----------
  const onImageUploadBefore = useCallback(async (files, info, uploadHandler) => {
    const file = files[0];
    if (!file) return;
    try {
      const publicUrl = await uploadFileToS3(file);
      // SunEditor expects uploadHandler to be called with result array
      uploadHandler({ result: [{ url: publicUrl, name: file.name }] });
    } catch (err) {
      console.error('toolbar image upload error', err);
    }
  }, [uploadFileToS3]);

  // ---------- Paste handler (handles pasted images) ----------
  const handlePaste = useCallback(async (e) => {
    try {
      const clipboardData = e.clipboardData || window.clipboardData;
      if (!clipboardData) return;
      const items = clipboardData.items || [];
      for (const item of items) {
        if (item.type && item.type.indexOf('image') !== -1) {
          const file = item.getAsFile();
          if (!file) continue;
          if (!adminToken) {
            console.error('Admin token missing for paste upload');
            continue;
          }
          setIsUploading(true);
          const publicUrl = await uploadFileToS3(file);
          setIsUploading(false);
          // insert image at current cursor position in the editor
          const editorInstance = editorRef.current?.editor;
          if (editorInstance && typeof editorInstance.insertHTML === 'function') {
            editorInstance.insertHTML(`<img src="${publicUrl}" style="max-width:100%;height:auto;" />`);
          }
          e.preventDefault();
          return;
        }
      }
    } catch (err) {
      console.error('paste handler error', err);
      setIsUploading(false);
    }
  }, [adminToken, uploadFileToS3]);

  // ---------- Drag & drop handler for Windows (global attach to editor container) ----------
  useEffect(() => {
    if (typeof window === 'undefined') return;
    const isWindows = navigator.platform.toLowerCase().includes('win');
    if (!isWindows) return;

    const editorContainer = () => {
      // suneditor root container (.se-wrapper)
      return document.querySelector('.se-wrapper');
    };

    const preventDefaults = (e) => {
      e.preventDefault();
      e.stopPropagation();
    };

    const onDrop = async (e) => {
      preventDefaults(e);
      const files = Array.from(e.dataTransfer.files || []);
      const imageFiles = files.filter(f => f.type.startsWith('image'));
      for (const file of imageFiles) {
        try {
          setIsUploading(true);
          const url = await uploadFileToS3(file);
          setIsUploading(false);
          const editorInstance = editorRef.current?.editor;
          if (editorInstance && typeof editorInstance.insertHTML === 'function') {
            editorInstance.insertHTML(`<img src="${url}" style="max-width:100%;height:auto;" />`);
          }
        } catch (err) {
          console.error('drag-drop upload error', err);
          setIsUploading(false);
        }
      }
    };

    const container = editorContainer();
    if (container) {
      container.addEventListener('dragenter', preventDefaults);
      container.addEventListener('dragover', preventDefaults);
      container.addEventListener('dragleave', preventDefaults);
      container.addEventListener('drop', onDrop);
    }

    return () => {
      if (container) {
        container.removeEventListener('dragenter', preventDefaults);
        container.removeEventListener('dragover', preventDefaults);
        container.removeEventListener('dragleave', preventDefaults);
        container.removeEventListener('drop', onDrop);
      }
    };
  }, [uploadFileToS3]);

  // ---------- Image resize click-cycle handler (like your Quill approach) ----------
  // Expose window.addImageResizeHandlers so your existing triggers still work
  useEffect(() => {
    window.addImageResizeHandlers = (updatePreviewCallback) => {
      const wrapperImgs = document.querySelectorAll('.se-wrapper .se-container img, .se-wrapper .se-editable img');
      wrapperImgs.forEach(img => {
        if (img.dataset.resizable) return;
        img.dataset.resizable = 'true';
        img.style.cursor = 'pointer';
        img.addEventListener('click', function (e) {
          e.preventDefault();
          const sizes = ['25%', '50%', '75%', '100%'];
          const currentWidth = img.style.width || '';
          const currentIndex = sizes.findIndex(s => s === currentWidth);
          const nextIndex = (currentIndex + 1) % sizes.length;
          img.style.width = sizes[nextIndex];
          img.style.height = 'auto';
          if (typeof updatePreviewCallback === 'function') {
            // ensure DOM update first
            requestAnimationFrame(() => updatePreviewCallback());
          }
        });
      });
    };
    return () => {
      // cleanup: remove dataset so it can reattach next time
      const imgs = document.querySelectorAll('.se-wrapper img[data-resizable="true"]');
      imgs.forEach(img => {
        delete img.dataset.resizable;
      });
    };
  }, []);

  // ---------- Keep an editor-ready flag for UI (mimic isQuillReady) ----------
  useEffect(() => {
    // when SunEditor component has mounted it will set editorRef; set ready true
    const timer = setTimeout(() => setIsEditorReady(true), 300);
    return () => clearTimeout(timer);
  }, []);

  // ---------- Keep topics in sync ----------
  useEffect(() => {
    const { stream, subject, standard } = formData;
    if (stream && subject && standard) {
      const topicsData = getTopics(stream, subject, standard);
      const topicsArray = Object.entries(topicsData);
      setTopics(topicsArray);
    } else {
      setTopics([]);
    }
  }, [formData.stream, formData.subject, formData.standard]);

  // ---------- Auto-fill marks ----------
  useEffect(() => {
    const fetchPredefined = async () => {
      if (formData.stream && formData.subject && !questionToEdit) {
        try {
          let questionType = 'MCQ';
          if (formData.userInputAnswer) questionType = 'Numerical';
          else if (formData.isMultipleAnswer) questionType = 'MCMA';
          const result = await getPredefinedMarks({
            stream: formData.stream,
            subject: formData.subject,
            standard: formData.standard || null,
            questionType
          });
          if (result.success && result.marks) {
            setFormData(prev => ({ ...prev, marks: result.marks.toString() }));
            setMarkingInfo({
              marks: result.marks,
              source: result.ruleSource,
              ruleId: result.ruleId,
              questionType
            });
          }
        } catch (err) {
          console.error('getPredefinedMarks error', err);
        }
      }
    };
    fetchPredefined();
  }, [formData.stream, formData.subject, formData.standard, formData.userInputAnswer, formData.isMultipleAnswer, questionToEdit]);

  // ---------- Helper: updatePreview (reads from formData state) ----------
  const updatePreview = useCallback(async () => {
    try {
      // If any content contains base64 images, run processImages
      const hasBase64 = (c) => c && c.includes('data:image/');
      const needsProcessing = hasBase64(formData.question) || hasBase64(formData.optionA) ||
                              hasBase64(formData.optionB) || hasBase64(formData.optionC) || hasBase64(formData.optionD);

      if (needsProcessing) {
        const pq = await processImages(formData.question || '');
        const pa = await processImages(formData.optionA || '');
        const pb = await processImages(formData.optionB || '');
        const pc = await processImages(formData.optionC || '');
        const pd = await processImages(formData.optionD || '');
        setPreviewContent({ question: pq, optionA: pa, optionB: pb, optionC: pc, optionD: pd });
      } else {
        setPreviewContent({
          question: formData.question || '',
          optionA: formData.optionA || '',
          optionB: formData.optionB || '',
          optionC: formData.optionC || '',
          optionD: formData.optionD || ''
        });
      }
    } catch (err) {
      console.error('updatePreview error', err);
    }
  }, [formData, processImages]);

  // run resize handler and math rendering shortly after tab change or content change
  useEffect(() => {
    const timer = setTimeout(() => {
      if (typeof window !== 'undefined' && isEditorReady) {
        // Detect and convert any Quill formulas when switching tabs
        if (window.detectAndConvertMathExpressions) {
          window.detectAndConvertMathExpressions();
        }
        
        // Render mathematical expressions
        if (window.renderAllMathExpressions) {
          window.renderAllMathExpressions();
        }
        
        // Add image resize handlers
        if (window.addImageResizeHandlers) {
          window.addImageResizeHandlers(updatePreview);
        }
      }
    }, 250);
    return () => clearTimeout(timer);
  }, [tabValue, isEditorReady, updatePreview]);


  // ---------- Enhanced Editor toolbar and options ----------
  const editorButtons = [
    ['undo', 'redo'],
    ['bold', 'italic', 'underline', 'subscript', 'superscript'],
    ['fontColor', 'hiliteColor'],
    ['align', 'list', 'table'],
    ['link', 'image', 'video'],
    ['codeView', 'formula', 'specialChars'],
    // Add some common math shortcuts as custom buttons if needed
  ];

  // ---------- Enhanced Editor onChange handler - update formData and detect math ----------
  const handleEditorChange = useCallback((content) => {
    setFormData(prev => {
      const next = { ...prev };
      if (tabValue === 0) next.question = content;
      else if (tabValue === 1) next.optionA = content;
      else if (tabValue === 2) next.optionB = content;
      else if (tabValue === 3) next.optionC = content;
      else if (tabValue === 4) next.optionD = content;
      return next;
    });

    // Enhanced processing after content change
    setTimeout(async () => {
      if (typeof window !== 'undefined') {
        const katex = await getKaTeX();
        if (katex) {
          // Re-render math expressions in the editor after content change
          const editorElement = document.querySelector('.se-wrapper .se-editable');
          if (editorElement) {
            const mathElements = editorElement.querySelectorAll('.se-math[data-latex], [data-latex], .katex-expression[data-latex]');
            mathElements.forEach(el => {
              if (el.dataset.latex) {
                try {
                  el.innerHTML = '';
                  katex.render(el.dataset.latex, el, { 
                    throwOnError: false,
                    displayMode: false,
                    output: 'html'
                  });
                } catch (err) {
                  console.warn('KaTeX render error:', err);
                  el.textContent = `[Math: ${el.dataset.latex}]`;
                }
              }
            });
          }
        }
        
        // Render any existing math expressions first
        if (window.renderAllMathExpressions) {
          window.renderAllMathExpressions();
        }
        
        // Auto-detect and convert mathematical expressions
        if (window.detectAndConvertMathExpressions) {
          window.detectAndConvertMathExpressions();
        }
        
        // Reattach image resize handlers
        if (window.addImageResizeHandlers) {
          window.addImageResizeHandlers(updatePreview);
        }
      }
    }, 150);
  }, [tabValue, updatePreview]);

  // ---------- Get editor value to pass to SunEditor using tabValue ----------
  const currentEditorValue = useMemo(() => {
    switch (tabValue) {
      case 0: return formData.question;
      case 1: return formData.optionA;
      case 2: return formData.optionB;
      case 3: return formData.optionC;
      case 4: return formData.optionD;
      default: return '';
    }
  }, [tabValue, formData]);

  // ---------- Enhanced keyboard shortcuts for tab switching and math input ----------
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.ctrlKey) {
        if (e.key === 'ArrowLeft') {
          e.preventDefault();
          setTabValue(prev => (prev > 0 ? prev - 1 : 0));
        } else if (e.key === 'ArrowRight') {
          e.preventDefault();
          setTabValue(prev => (prev < 5 ? prev + 1 : 5));
        } else if (e.key >= '1' && e.key <= '6') {
          e.preventDefault();
          setTabValue(Number(e.key) - 1);
        } else if (e.key === 'm' || e.key === 'M') {
          // Quick math input: Ctrl+M
          e.preventDefault();
          const latex = window.prompt('Quick LaTeX input (without $):', '');
          if (latex && editorRef.current?.editor) {
            const mathHtml = `<span class="se-math" data-latex="${latex}"></span>`;
            editorRef.current.editor.insertHTML(mathHtml);
            setTimeout(() => {
              if (window.renderAllMathExpressions) {
                window.renderAllMathExpressions();
              }
            }, 50);
          }
        }
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  // ---------- Validation ----------
  const validateForm = useCallback(() => {
    const requiredFields = {
      stream: 'Stream',
      standard: 'Standard',
      subject: 'Subject',
      question: 'Question',
      marks: 'Marks',
      difficultyLevel: 'Difficulty Level'
    };
    const errors = [];
    Object.entries(requiredFields).forEach(([field, label]) => {
      if (!formData[field]) errors.push(`${label} is required`);
    });
    if (formData.marks && (isNaN(formData.marks) || formData.marks <= 0)) errors.push('Marks must be a positive number');
    if (formData.userInputAnswer) {
      if (!formData.answer) errors.push('Answer is required for user input questions');
    } else if (formData.isMultipleAnswer) {
      if (formData.multipleAnswer.length < 2) errors.push('Select at least 2 correct options for multiple answer questions');
      if (!formData.optionA || !formData.optionB || !formData.optionC || !formData.optionD) errors.push('All options must be filled for multiple choice questions');
    } else {
      if (!formData.optionA || !formData.optionB || !formData.optionC || !formData.optionD) errors.push('All options must be filled for multiple choice questions');
      if (!['A','B','C','D'].includes(formData.answer)) errors.push('Select one correct answer for single choice questions');
    }
    return errors;
  }, [formData]);

  // ---------- Submit ----------
  const handleSubmit = useCallback(async () => {
    const validation = validateForm();
    if (validation.length > 0) {
      alert(validation.join('\n'));
      return;
    }

    // process images in HTML content (data: => upload)
    const processedQuestion = await processImages(formData.question);
    const processedA = await processImages(formData.optionA);
    const processedB = await processImages(formData.optionB);
    const processedC = await processImages(formData.optionC);
    const processedD = await processImages(formData.optionD);

    setPreviewContent({
      question: processedQuestion,
      optionA: processedA,
      optionB: processedB,
      optionC: processedC,
      optionD: processedD
    });

    const questionData = {
      stream: formData.stream,
      standard: formData.standard,
      topic: formData.topic,
      question: processedQuestion,
      subject: formData.subject,
      marks: parseInt(formData.marks) || 4,
      section: parseInt(formData.section) || 1,
      userInputAnswer: formData.userInputAnswer,
      isMultipleAnswer: formData.isMultipleAnswer,
      answer: formData.isMultipleAnswer ? formData.multipleAnswer[0] : formData.answer,
      multipleAnswer: formData.isMultipleAnswer ? formData.multipleAnswer : [],
      options: formData.userInputAnswer ? [] : [processedA, processedB, processedC, processedD],
      difficultyLevel: formData.difficultyLevel
    };

    try {
      let result;
      if (questionToEdit) {
        result = await updateExamQuestion({
          ...questionData,
          _id: questionToEdit._id,
          questionNumber: questionToEdit.questionNumber,
          difficultyLevel: formData.difficultyLevel
        });
      } else {
        result = await addExamQuestion(questionData);
      }
      if (result.success) {
        alert(result.message);
        if (typeof onUpdate === 'function') onUpdate();
        if (typeof onClose === 'function') onClose();
      } else {
        alert(result.message || 'Operation failed');
      }
    } catch (err) {
      alert(err.message || 'Error processing question');
    }
  }, [formData, processImages, questionToEdit, onClose, onUpdate, validateForm]);

  // ---------- Helper: S3 connection test (kept) ----------
  const testS3Connection = useCallback(async () => {
    try {
      const response = await fetch('https://api.drcexam.in/getPreSignedURL', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${adminToken}` },
        body: JSON.stringify({ fileName: 'test.jpg', type: 'questionImage' })
      });
      if (!response.ok) {
        const errorData = await response.json();
        console.error('API Error:', errorData);
        return null;
      }
      const data = await response.json();
      console.log('Pre-signed URL response:', data);
      return data;
    } catch (err) {
      console.log('Connection test error:', err);
      return null;
    }
  }, [adminToken]);

  // ---------- Form field change helpers ----------
  const handleStreamChange = (e) => {
    const newStream = e.target.value;
    setFormData({
      ...formData,
      stream: newStream,
      subject: '',
      standard: '',
      section: '',
      topic: '',
      userInputAnswer: false,
      isMultipleAnswer: false
    });
  };

  const handleSubjectChange = (e) => {
    setFormData({ ...formData, subject: e.target.value, standard: '', section: '', topic: '' });
  };

  const handleStandardChange = (e) => {
    setFormData({ ...formData, standard: e.target.value, section: '', topic: '' });
  };

  // ---------- Focus behaviour similar to original (focus editor on tab=0) ----------
  useEffect(() => {
    if (isEditorReady && editorRef.current && tabValue === 0) {
      try {
        const ed = editorRef.current.editor;
        if (ed && typeof ed.focus === 'function') {
          ed.focus();
        }
      } catch (err) {
        // ignore
      }
    }
  }, [isEditorReady, tabValue]);

  // ---------- UI render ----------
  return (
    <div className="w-full bg-white rounded-xl shadow-lg overflow-hidden">
      {/* Header */}
      <div className="p-6 border-b">
        <h1 className="text-2xl md:text-3xl font-semibold text-gray-900 flex items-center gap-2">
          <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-[#1d77bc]" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d={questionToEdit ?
              "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" :
              "M9 13h6m-3-3v6m-9 1V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2z"} />
          </svg>
          {questionToEdit ? 'Update Question' : 'Add Question'}
        </h1>
      </div>

      {/* Form fields (streams, subject, standard, section, topic, difficulty) */}
      <div className="grid grid-cols-2 md:grid-cols-5 gap-3 p-4">
        <select value={formData.stream} onChange={handleStreamChange} className="w-full border border-gray-200 rounded-lg p-2 text-sm focus:ring-2 focus:ring-[#1d77bc] focus:border-transparent">
          <option value="">Stream</option>
          <option value="NEET">NEET</option>
          <option value="JEE">JEE</option>
          <option value="MHT-CET">MHT-CET</option>
        </select>

        <select value={formData.subject} onChange={handleSubjectChange} className="w-full border border-gray-200 rounded-lg p-2 text-sm focus:ring-2 focus:ring-[#1d77bc] focus:border-transparent" disabled={!formData.stream}>
          <option value="">Select Subject</option>
          {subjects && subjects.length > 0 && subjects.map(sub => <option key={sub.value} value={sub.value}>{sub.label}</option>)}
        </select>

        <select value={formData.standard} onChange={handleStandardChange} className="w-full border border-gray-200 rounded-lg p-2 text-sm focus:ring-2 focus:ring-[#1d77bc] focus:border-transparent" disabled={!formData.subject}>
          <option value="">Select Standard</option>
          <option value="11">11th</option>
          <option value="12">12th</option>
        </select>

        {formData.stream !== 'MHT-CET' && formData.stream !== 'NEET' && formData.stream && (
          <select value={formData.section} onChange={(e) => setFormData({...formData, section: e.target.value})} className="w-full border border-gray-200 rounded-lg p-2 text-sm focus:ring-2 focus:ring-[#1d77bc] focus:border-transparent">
            <option value="">Select Section</option>
            <option value="1">Section A</option>
            <option value="2">Section B</option>
          </select>
        )}

        <select value={formData.topic} onChange={(e) => setFormData({...formData, topic: e.target.value})} className="w-full border border-gray-200 rounded-lg p-2 text-sm focus:ring-2 focus:ring-[#1d77bc] focus:border-transparent" disabled={!topics.length}>
          <option value="">Select Topic</option>
          {topics.map(([topic, id]) => <option key={id} value={id}>{topic}</option>)}
        </select>

        <select value={formData.difficultyLevel} onChange={(e) => setFormData({...formData, difficultyLevel: e.target.value})} className="w-full border border-gray-200 rounded-lg p-2 text-sm focus:ring-2 focus:ring-[#1d77bc] focus:border-transparent">
          <option value="Easy">Easy</option>
          <option value="Medium">Medium</option>
          <option value="Hard">Hard</option>
        </select>
      </div>

      {/* Preview */}
      <div className="bg-white rounded-xl shadow-lg p-4 mb-4 mx-4">
        {/* Targeted CSS fix for KaTeX rendering in preview */}
        <style>{`
          .katex-container .katex {
            font-size: 1em !important;
            line-height: 1.2 !important;
          }
          .katex-container .katex .sqrt svg {
            width: auto !important;
            max-width: 100% !important;
            height: 1em !important;
          }
          .katex-container .katex .sqrt .hide-tail {
            width: auto !important;
            min-width: 0.853em !important;
            max-width: 100% !important;
          }
        `}</style>
        <div className="flex items-center justify-between mb-3">
          <h3 className="text-base font-semibold text-gray-800">Preview</h3>
          <span className="text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded-full">Live Preview</span>
        </div>
        <div className="bg-gray-50 rounded-xl p-4 space-y-4">
          <div className="bg-white rounded-lg p-3 shadow-sm">
            <div className="text-sm font-medium text-gray-700 mb-2">Question</div>
            <div className="katex-container" dangerouslySetInnerHTML={{ __html: previewContent.question || formData.question }} />
          </div>
          <div className="grid grid-cols-2 gap-3">
            {['A','B','C','D'].map((opt) => (
              <div key={opt} className="bg-white rounded-lg p-3 shadow-sm">
                <div className="flex items-center gap-2 mb-2">
                  <span className="w-6 h-6 rounded-full bg-[#1d77bc] text-white flex items-center justify-center text-sm">{opt}</span>
                </div>
                <div className="katex-container" dangerouslySetInnerHTML={{ __html: previewContent[`option${opt}`] || formData[`option${opt}`] }} />
              </div>
            ))}
          </div>
        </div>
      </div>

      {/* Tabs */}
      <div className="mx-4 mb-3">
        <div className="flex bg-gray-50 rounded-xl p-1">
          {['Question','Option A','Option B','Option C','Option D','Answer'].map((tab, idx) => (
            <button key={idx} className={`flex-1 px-4 py-2 text-sm font-medium rounded-lg transition-all duration-200 ${tabValue===idx ? 'bg-white text-[#1d77bc] shadow-sm' : 'text-gray-600 hover:bg-gray-100'}`} onClick={() => setTabValue(idx)}>
              <span>{tab}</span>
              <span className="ml-2 text-xs text-gray-400 font-normal">Ctrl+{idx+1}</span>
            </button>
          ))}
        </div>
        <div className="mt-2 text-xs text-gray-500 flex items-center gap-2">
          <svg className="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" d="M13 16h-1v-4h-1m1-4h.01M12 20a8 8 0 100-16 8 8 0 000 16z" /></svg>
          <span>Use <span className="font-medium text-gray-600">Ctrl + 1-6</span> to switch tabs, <span className="font-medium text-gray-600">Ctrl + ←/→</span> to move between tabs, or <span className="font-medium text-gray-600">Ctrl + M</span> for quick math input.</span>
        </div>
      </div>

      {/* Editor area */}
      <div className="mx-4 mb-2 relative">
        {/* Targeted CSS fix for KaTeX rendering in SunEditor */}
        <style>{`
          .se-wrapper .katex,
          .se-container .katex,
          .se-editable .katex {
            font-size: 1em !important;
            line-height: 1.2 !important;
            display: inline-block !important;
          }
          .se-wrapper .katex .sqrt svg,
          .se-container .katex .sqrt svg,
          .se-editable .katex .sqrt svg {
            width: auto !important;
            max-width: 100% !important;
            height: 1em !important;
          }
          .se-wrapper .katex .sqrt .hide-tail,
          .se-container .katex .sqrt .hide-tail,
          .se-editable .katex .sqrt .hide-tail {
            width: auto !important;
            min-width: 0.853em !important;
            max-width: 100% !important;
          }
          .se-wrapper .se-math,
          .se-container .se-math,
          .se-editable .se-math {
            display: inline-block !important;
            vertical-align: baseline !important;
          }
        `}</style>
        {/* Editor */}
        {tabValue === 5 ? (
          <div className="bg-white rounded-xl shadow-sm p-4 space-y-4">
            {/* Answer tab content (unchanged) */}
            <div className="flex flex-col gap-3">
              <div className="flex items-center gap-3 p-3 bg-gray-50 rounded-lg">
                {formData.stream === 'JEE' && (
                  <div className="flex items-center gap-3 mr-6">
                    <input type="checkbox" id="userInputToggle" checked={formData.userInputAnswer} onChange={(e) => setFormData({...formData, userInputAnswer: e.target.checked, isMultipleAnswer: false})} className="w-4 h-4 text-[#1d77bc] rounded focus:ring-[#1d77bc]" />
                    <label htmlFor="userInputToggle" className="text-sm text-gray-700 font-medium">Numerical Answer (NAT)</label>
                    <span className="text-xs text-gray-500 bg-blue-100 px-2 py-1 rounded-full">JEE Only</span>
                  </div>
                )}
                {formData.stream === 'JEE' && (
                  <div className="flex items-center gap-3">
                    <input type="checkbox" id="multipleAnswerToggle" checked={formData.isMultipleAnswer} onChange={(e) => setFormData({...formData, isMultipleAnswer: e.target.checked, userInputAnswer: false})} className="w-4 h-4 text-[#1d77bc] rounded focus:ring-[#1d77bc]" />
                    <label htmlFor="multipleAnswerToggle" className="text-sm text-gray-700 font-medium">Multiple Correct Options (MCMA)</label>
                    <span className="text-xs text-gray-500 bg-blue-100 px-2 py-1 rounded-full">JEE Only</span>
                  </div>
                )}
                {(formData.stream === 'NEET' || formData.stream === 'MHT-CET') && (
                  <div className="flex items-center gap-2">
                    <span className="text-sm text-gray-600">📝 {formData.stream} uses only Multiple Choice Questions (MCQ) format</span>
                    <span className="text-xs text-gray-500 bg-green-100 px-2 py-1 rounded-full">Standard MCQ</span>
                  </div>
                )}
              </div>

              <div className="grid grid-cols-2 gap-4">
                <div className="space-y-2">
                  <label className="text-sm font-medium text-gray-700">Answer</label>
                  {formData.userInputAnswer ? (
                    <input type="text" placeholder="Enter numeric or text answer" className="w-full border rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:border-transparent" value={formData.answer} onChange={(e) => setFormData({...formData, answer: e.target.value})} />
                  ) : formData.isMultipleAnswer ? (
                    <div className="space-y-2 p-3 border rounded-lg">
                      {['A','B','C','D'].map(o => (
                        <div key={o} className="flex items-center gap-2">
                          <input type="checkbox" id={`option${o}`} checked={formData.multipleAnswer.includes(o)} onChange={(e) => {
                            const next = e.target.checked ? [...formData.multipleAnswer, o] : formData.multipleAnswer.filter(a => a !== o);
                            setFormData({...formData, multipleAnswer: next});
                          }} className="w-4 h-4 text-[#1d77bc] rounded focus:ring-[#1d77bc]" />
                          <label htmlFor={`option${o}`} className="text-sm">Option {o}</label>
                        </div>
                      ))}
                    </div>
                  ) : (
                    <select value={formData.answer} onChange={(e) => setFormData({...formData, answer: e.target.value})} className="w-full border rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                      <option value="">Select Answer</option>
                      <option value="A">A</option>
                      <option value="B">B</option>
                      <option value="C">C</option>
                      <option value="D">D</option>
                    </select>
                  )}
                </div>
                <div className="space-y-2">
                  <label className="text-sm font-medium text-gray-700">Marks</label>
                  <div className="relative">
                    <input type="number" placeholder="Enter marks" className="w-full border rounded-lg p-3 bg-gray-50 text-gray-600 cursor-not-allowed" value={formData.marks} disabled readOnly />
                    {markingInfo && (
                      <div className="mt-1 text-xs text-green-600 bg-green-50 px-2 py-1 rounded-md">
                        <span className="font-medium">Auto-filled ({markingInfo.questionType}):</span> {markingInfo.source}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </div>
          </div>
        ) : (
          isEditorReady && (
            <div key={`sun-${tabValue}`} className="min-h-[300px]">
              <SunEditor
                ref={editorRef}
                defaultValue={currentEditorValue}
                setContents={currentEditorValue}
                onChange={handleEditorChange}
                setOptions={{
                  height: 350,
                  buttonList: editorButtons,
                  plugins: { ...plugins },
                  // keep default other options
                }}
                onImageUploadBefore={onImageUploadBefore}
                onPaste={handlePaste}
                onLoad={() => {
                  // Enhanced math rendering on load
                  setTimeout(async () => {
                    const katex = await getKaTeX();
                    if (katex) {
                      // Render any existing math expressions in the editor
                      const editorElement = document.querySelector('.se-wrapper .se-editable');
                      if (editorElement) {
                        const mathElements = editorElement.querySelectorAll('.se-math[data-latex], [data-latex], .katex-expression[data-latex]');
                        mathElements.forEach(el => {
                          if (el.dataset.latex) {
                            try {
                              el.innerHTML = '';
                              katex.render(el.dataset.latex, el, { 
                                throwOnError: false,
                                displayMode: false,
                                output: 'html'
                              });
                            } catch (err) {
                              console.warn('KaTeX render error:', err);
                              el.textContent = `[Math: ${el.dataset.latex}]`;
                            }
                          }
                        });
                      }
                    }
                    
                    // First detect and convert any Quill formulas to our format
                    if (window.detectAndConvertMathExpressions) {
                      window.detectAndConvertMathExpressions();
                    }
                    
                    // Then render all math expressions
                    if (window.renderAllMathExpressions) {
                      window.renderAllMathExpressions();
                    }
                    
                    // Also process preview
                    updatePreview();
                  }, 200);
                }}
                autoFocus={tabValue === 0}
                onBlur={async () => {
                  // Enhanced blur handler - render math and update preview
                  setTimeout(async () => {
                    const katex = await getKaTeX();
                    if (katex) {
                      // Re-render any math expressions in the editor
                      const editorElement = document.querySelector('.se-wrapper .se-editable');
                      if (editorElement) {
                        const mathElements = editorElement.querySelectorAll('.se-math[data-latex], [data-latex], .katex-expression[data-latex]');
                        mathElements.forEach(el => {
                          if (el.dataset.latex) {
                            try {
                              el.innerHTML = '';
                              katex.render(el.dataset.latex, el, { 
                                throwOnError: false,
                                displayMode: false,
                                output: 'html'
                              });
                            } catch (err) {
                              console.warn('KaTeX render error:', err);
                              el.textContent = `[Math: ${el.dataset.latex}]`;
                            }
                          }
                        });
                      }
                    }
                    
                    if (window.renderAllMathExpressions) {
                      window.renderAllMathExpressions();
                    }
                    if (window.detectAndConvertMathExpressions) {
                      window.detectAndConvertMathExpressions();
                    }
                    updatePreview();
                  }, 50);
                }}
                onImageUpload={(targetImgElement, index, state, imageInfo, remainingFilesCount) => {
                  // (Not used since we handle onImageUploadBefore)
                }}
              />
            </div>
          )
        )}
      </div>

      {/* Bottom save */}
      <div className="sticky bottom-0 left-0 right-0 bg-white border-t shadow-md px-6 py-4">
        <div className="max-w-screen-xl mx-auto flex justify-end items-center">
          <button onClick={handleSubmit} disabled={isUploading} className={`bg-[#e96030] text-white px-8 py-3 rounded-lg hover:opacity-90 transition-all duration-200 shadow-md flex items-center gap-2 font-medium ${isUploading ? 'opacity-75' : ''}`}>
            {isUploading ? (
              <>
                <span>Uploading...</span>
                <svg className="animate-spin h-5 w-5" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                </svg>
              </>
            ) : (
              <>
                <span>Save Question</span>
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                </svg>
              </>
            )}
          </button>
        </div>
      </div>
    </div>
  );
};

export default AddQuestion;
